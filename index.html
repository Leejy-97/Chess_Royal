<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
<title>Chess Royale – 풀버전 (PWA)</title>

<!-- PWA & 모바일 전체화면 -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#1e3c72">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<link rel="apple-touch-icon" href="icons/icon-192.png">

<style>
  *{box-sizing:border-box}
  body{
    font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background:linear-gradient(135deg,#1e3c72 0%,#2a5298 100%);
    min-height:100vh; margin:0; color:#333; padding:24px; display:flex; align-items:center; justify-content:center;
    padding-top:calc(env(safe-area-inset-top,0px) + 24px);
    padding-bottom:calc(env(safe-area-inset-bottom,0px) + 24px);
  }
  body>.screen{display:none; width:min(1200px,96vw)}
  .card{
    background:rgba(255,255,255,.95); border-radius:16px; padding:24px;
    box-shadow:0 12px 36px rgba(0,0,0,.35);
  }
  h1,h2{margin:0 0 12px}
  .btn{border:none; border-radius:10px; padding:12px 16px; background:#3498db; color:#fff; cursor:pointer; font-size:16px}
  .btn:hover{background:#2980b9}
  .btn.gray{background:#95a5a6}.btn.gray:hover{background:#7f8c8d}
  .btn.warn{background:#e67e22}.btn.warn:hover{background:#d35400}
  .btn.danger{background:#e74c3c}.btn.danger:hover{background:#c0392b}
  .row{display:flex; gap:12px; flex-wrap:wrap}
  .center{display:flex; align-items:center; justify-content:center}
  .stack{display:flex; flex-direction:column; gap:10px}

  /* 게임 레이아웃 */
  .game-container{display:flex; gap:16px}
  .board-section,.control-section{
    background:rgba(255,255,255,.95); border-radius:16px; padding:16px;
    box-shadow:0 8px 26px rgba(0,0,0,.3);
  }
  .board-section{flex:2}
  .control-section{flex:1; max-height:85vh; overflow:auto}

  .info{background:#f7f9fb; border-left:4px solid #3498db; padding:12px; border-radius:10px; margin-bottom:12px}
  .meta{font-size:14px; color:#2c3e50}
  .turn-order{margin-top:6px; font-size:13px; color:#444}

  .chessboard{
    width:512px; height:512px; margin:0 auto 10px;
    border:3px solid #2c3e50; display:grid; grid-template-columns:repeat(8,1fr); grid-template-rows:repeat(8,1fr)
  }
  .square{display:flex; align-items:center; justify-content:center; position:relative; font-size:24px; cursor:pointer}
  .light{background:#f0d9b5}
  .dark{background:#b58863}
  .square.selected{outline:3px solid rgba(255,255,0,.85)}
  .square.possible{box-shadow:inset 0 0 0 3px rgba(46,204,113,.75)}

  .king{font-size:30px; font-weight:700; text-shadow:2px 2px 4px rgba(0,0,0,.45); transition:.15s}
  .king.player1{color:#e74c3c}.king.player2{color:#3498db}.king.player3{color:#2ecc71}.king.player4{color:#f39c12}
  .king.moving{transform:scale(1.08)}
  .king.joker{animation:jokerFx 1.1s ease-in-out}
  @keyframes jokerFx{
    0%{transform:scale(1); filter:brightness(1)}
    30%{transform:scale(1.22); filter:brightness(1.8) hue-rotate(260deg)}
    60%{transform:scale(1.08); filter:brightness(1.4) hue-rotate(120deg)}
    100%{transform:scale(1); filter:brightness(1)}
  }
  .health-bar{position:absolute; bottom:4px; left:50%; transform:translateX(-50%); display:flex; gap:3px}
  .dot{width:8px; height:8px; border-radius:50%; background:#e74c3c}

  .logs{height:180px; overflow:auto; background:#f8f9fa; border-radius:10px; padding:10px; border:1px solid #eaeaea; text-align:left}
  .log{font-size:13px; padding:3px 0; border-bottom:1px dashed #eee}
  .log.joker{background:rgba(255,107,107,.18); border-left:3px solid #ff6b6b; padding:6px; border-radius:6px}

  .pbox{padding:8px 10px; background:#f7f7f7; border-radius:10px; border:1px solid #eee; margin-bottom:8px}
  .pbox.dead{opacity:.45; background:#fde2e2}
  .pname{font-weight:700; display:flex; align-items:center; gap:6px}

  .badge{display:inline-block; padding:2px 6px; font-size:11px; border-radius:6px; margin-left:6px; color:#fff}
  .ai{background:#007bff}.charged{background:#4ecdc4; animation:pulse 1s infinite}.used{background:#777}
  @keyframes pulse{0%{opacity:1}50%{opacity:.55}100%{opacity:1}}

  .pieces-grid{display:grid; grid-template-columns:repeat(6,1fr); gap:8px}
  .pcard{background:#fff; border:2px solid #e5e7eb; border-radius:10px; padding:8px; text-align:center; cursor:pointer}
  .pcard:hover{transform:translateY(-2px); border-color:#3498db}
  .pcard.sel{border-color:#e67e22; background:#fff3e0}
  .pcard.dis{opacity:.45; pointer-events:none}
  .pcard.joker-ready{background:linear-gradient(45deg,#ff6b6b,#4ecdc4,#45b7d1); color:#fff; font-weight:700}
  .pcard.joker-used{background:#666; color:#ddd}

  @media(max-width:980px){
    .game-container{flex-direction:column}
    .chessboard{width:92vw; height:92vw} /* 모바일 보드 자동 맞춤 */
    .square{font-size:18px}
    .king{font-size:22px}
    .pieces-grid{grid-template-columns:repeat(4,1fr)}
  }

  /* 결과 오버레이 */
  .overlay{
    position:fixed; inset:0; background:rgba(0,0,0,.55);
    display:flex; align-items:center; justify-content:center; z-index:9999;
  }
  .modal{
    background:#fff; padding:24px; border-radius:16px; width:min(520px,90vw);
    box-shadow:0 14px 40px rgba(0,0,0,.4); text-align:center;
  }
  .modal h2{margin-top:0}

  /* 이름 색상 & 스와치 */
  .nameClr.player1{color:#e74c3c}
  .nameClr.player2{color:#3498db}
  .nameClr.player3{color:#2ecc71}
  .nameClr.player4{color:#f39c12}
  .swatch{
    width:12px; height:12px; border-radius:50%; display:inline-block;
    border:1px solid rgba(0,0,0,.25); vertical-align:middle
  }
  .swatch.player1{background:#e74c3c}
  .swatch.player2{background:#3498db}
  .swatch.player3{background:#2ecc71}
  .swatch.player4{background:#f39c12}
</style>
</head>
<body>

<!-- 메인 화면 -->
<div id="startScreen" class="screen" style="display:block;">
  <div class="card center" style="flex-direction:column; gap:18px">
    <h1>Chess Royale</h1>
    <div class="row center">
      <button class="btn" onclick="showScreen('difficultyScreen')">게임 시작</button>
      <button class="btn gray" onclick="showScreen('settingsScreen')">설정</button>
      <button class="btn warn" onclick="showScreen('helpScreen')">게임 설명</button>
      <!-- PWA 설치 버튼(안드로이드에서 beforeinstallprompt가 올 때만 표시) -->
      <button class="btn" id="installBtn" style="display:none">설치</button>
    </div>
  </div>
</div>

<!-- 난이도 -->
<div id="difficultyScreen" class="screen">
  <div class="card center" style="flex-direction:column; gap:12px">
    <h2>난이도 선택</h2>
    <div class="row">
      <button class="btn" onclick="startGame('easy')">이지</button>
      <button class="btn" onclick="startGame('middle')">미들</button>
      <button class="btn" onclick="startGame('hard')">하드</button>
    </div>
    <div class="row">
      <button class="btn gray" onclick="showScreen('startScreen')">뒤로가기</button>
    </div>
  </div>
</div>

<!-- 설정 -->
<div id="settingsScreen" class="screen">
  <div class="card stack">
    <h2>설정</h2>
    <label><input type="checkbox" id="soundToggle" checked> 효과음 켜기</label>
    <label><input type="checkbox" id="bgmToggle" checked> 배경음악 켜기</label>
    <div class="row"><button class="btn gray" onclick="showScreen('startScreen')">뒤로가기</button></div>
  </div>
</div>

<!-- 설명 -->
<div id="helpScreen" class="screen">
  <div class="card stack">
    <h2>게임 설명</h2>
    <div class="stack" style="line-height:1.6">
      <div>체스 기반 4인 배틀로얄. 플레이어 1 + AI 3, 8×8 보드에서 마지막 생존 승리.</div>
      <div>• 각 킹 체력 3. 0이 되면 탈락.</div>
      <div>• <b>조커 🃏</b>: <b>제자리에서</b> 같은 칸의 모든 적에게 <b>3 데미지</b>. 조커로 처치 시 <b>재충전</b>.</div>
      <div>• 매 턴 “계획 → 동시에 실행”. 같은 칸 겹치면 충돌 피해.</div>
      <div>• Undo로 직전 상태로 복구 가능.</div>
      <div>• 난이도: Easy(실수↑), Middle(기본), Hard(예측/공격↑, 중앙성향↑)</div>
    </div>
    <div class="row"><button class="btn gray" onclick="showScreen('startScreen')">뒤로가기</button></div>
  </div>
</div>

<!-- 게임 화면 -->
<div id="gameScreen" class="screen">
  <div class="game-container">
    <div class="board-section">
      <h2>게임 화면</h2>
      <div class="info">
        <div class="meta">
          <b>현재:</b> <span id="currentPlayer">-</span>
          &nbsp;|&nbsp; <b>턴:</b> <span id="phaseInfo">-</span>
        </div>
        <div class="turn-order" id="turnOrderText">턴 순서 변경: -</div>
        <div id="actionInfo" style="margin-top:6px; color:#333">-</div>
      </div>
      <div id="chessboard" class="chessboard"></div>
      <div class="row" style="margin-top:6px">
        <button id="confirmMove" class="btn" disabled>이동 확정</button>
        <button id="resetMove" class="btn gray">취소</button>
        <button id="undoMove" class="btn gray" disabled>무르기</button>
        <button id="toMenu" class="btn warn">메인으로</button>
        <button id="newGame" class="btn danger">새 게임</button>
      </div>
      <div class="logs" id="gameLogs" style="margin-top:10px"></div>
    </div>

    <div class="control-section">
      <h3 style="margin:0 0 8px">플레이어 상태</h3>
      <div id="playersStatus"></div>

      <h3 style="margin:14px 0 8px">기물 선택 (플레이어 전용)</h3>
      <div id="piecesGrid" class="pieces-grid"></div>
      <div style="font-size:12px; color:#666; margin-top:8px">💀 <b>조커:</b> 제자리에서 같은 칸의 모든 적에게 3 데미지 (킬 시 재충전)</div>
    </div>
  </div>
</div>

<script>
  /* 화면 전환 */
  function showScreen(id){
    document.querySelectorAll('body > .screen').forEach(s=>s.style.display='none');
    document.getElementById(id).style.display='block';
    const ov = document.getElementById('resultOverlay'); if(ov) ov.remove();
  }
  function startGame(difficulty){
    window.selectedDifficulty = difficulty;
    showScreen('gameScreen');
    window.chessGame = new ChessRoyale(difficulty);
  }
  function restartWithSameDifficulty(){
    const diff = window.selectedDifficulty || 'middle';
    startGame(diff);
  }

  /* 결과 오버레이 */
  function showResultOverlay(message){
    const old=document.getElementById('resultOverlay'); if(old) old.remove();
    const overlay=document.createElement('div');
    overlay.id='resultOverlay'; overlay.className='overlay';
    overlay.innerHTML = `
      <div class="modal">
        <h2>${message}</h2>
        <div class="row" style="justify-content:center; margin-top:8px">
          <button class="btn" id="overlayRestart">다시하기</button>
          <button class="btn gray" id="overlayToMenu">메인 화면으로</button>
        </div>
      </div>`;
    document.body.appendChild(overlay);
    document.getElementById('overlayRestart').onclick = restartWithSameDifficulty;
    document.getElementById('overlayToMenu').onclick = ()=>{ overlay.remove(); showScreen('startScreen'); };
  }

  /* 게임 본체 (이전 풀버전 로직 유지) */
  class ChessRoyale{
    constructor(difficulty='middle'){
      this.difficulty = difficulty;
      this.boardSize = 8;

      this.players = [
        { id:1, name:'플레이어', color:'player1', health:3, position:{x:0,y:0}, alive:true, isAI:false, jokerUsed:false },
        { id:2, name:'AI 알파',  color:'player2', health:3, position:{x:7,y:0}, alive:true, isAI:true,  jokerUsed:false },
        { id:3, name:'AI 베타',  color:'player3', health:3, position:{x:0,y:7}, alive:true, isAI:true,  jokerUsed:false },
        { id:4, name:'AI 감마',  color:'player4', health:3, position:{x:7,y:7}, alive:true, isAI:true,  jokerUsed:false },
      ];

      this.pieces = {
        '♟': { name:'폰',   moves:this.getPawnMoves   },
        '♜': { name:'룩',   moves:this.getRookMoves   },
        '♞': { name:'나이트', moves:this.getKnightMoves },
        '♝': { name:'비숍', moves:this.getBishopMoves },
        '♛': { name:'퀸',   moves:this.getQueenMoves  },
        '♚': { name:'킹',   moves:this.getKingMoves   },
        '🃏': { name:'조커', moves:this.getJokerMoves  },
      };

      this.playerDecks = {};
      this.currentPlayer = 0;
      this.currentTurn = 1;
      this.turnOrder = [0,1,2,3];
      this.selectedPiece = null;
      this.selectedMove = null;
      this.pendingMoves = [];
      this.gamePhase = 'selection';
      this.gameHistory = [];
      this.maxHistoryLength = 8;

      this.lastTurnOrderText = '턴 순서 변경: ' + this.turnOrder.map(i=>this.coloredName(this.players[i])).join(' → ');

      this.createBoard();
      this.initializeDecks();
      this.bindEvents();
      this.updateDisplay();

      this.addLog('난이도: ' + this.difficulty + ' | 게임 시작!');
      this.addJokerLog('💀 조커: 제자리에서 같은 칸의 적들에게 3 데미지! (킬 시 재충전)');
    }

    coloredName(player){
      return `<span class="swatch ${player.color}"></span><span class="nameClr ${player.color}">${player.name}</span>`;
    }

    createBoard(){
      const board = document.getElementById('chessboard');
      board.innerHTML='';
      for(let y=0;y<this.boardSize;y++){
        for(let x=0;x<this.boardSize;x++){
          const d=document.createElement('div');
          d.className='square ' + ((x+y)%2===0?'light':'dark');
          d.dataset.row=y; d.dataset.col=x;
          d.addEventListener('click',()=>this.handleSquareClick(y,x));
          board.appendChild(d);
        }
      }
    }
    renderPieces(){
      document.querySelectorAll('.square').forEach(s=>{ s.innerHTML=''; s.classList.remove('selected','possible'); });
      this.players.forEach(p=>{
        if(!p.alive) return;
        const sq = document.querySelector(`.square[data-row="${p.position.y}"][data-col="${p.position.x}"]`);
        if(!sq) return;
        sq.innerHTML = `<div class="king ${p.color}">♔</div>`;
        const hb=document.createElement('div'); hb.className='health-bar';
        for(let i=0;i<p.health;i++){ const dot=document.createElement('div'); dot.className='dot'; hb.appendChild(dot); }
        sq.appendChild(hb);
      });
    }
    updateDisplay(){
      this.renderPieces();
      this.updatePlayerStatus();
      this.updatePieceSelection();
      this.updateTurnInfo();
      this.updateUndoButton();
    }
    updateTurnInfo(){
      const cur = this.players[this.currentPlayer];
      document.getElementById('currentPlayer').innerHTML = this.coloredName(cur);
      document.getElementById('phaseInfo').textContent = this.currentTurn;
      document.getElementById('turnOrderText').innerHTML = this.lastTurnOrderText;

      const text = this.gamePhase==='ended' ? '게임 종료!' :
                   this.gamePhase==='executing' ? '계획 실행 중...' :
                   cur.isAI ? `${cur.name}이 생각 중...` :
                   (this.selectedPiece==='🃏' ? '조커 선택됨 - 제자리에서 광역 공격!' :
                     (this.selectedPiece ? this.pieces[this.selectedPiece].name+' 선택됨 - 이동 위치 클릭'
                                         : '기물을 선택하고 이동할 위치를 클릭하세요'));
      document.getElementById('actionInfo').textContent = text;
    }

    updatePlayerStatus(){
      const box = document.getElementById('playersStatus');
      box.innerHTML='';
      this.players.forEach((p)=>{
        const div=document.createElement('div');
        div.className='pbox'+(p.alive?'':' dead');
        const hearts='♥'.repeat(p.health);
        const aiBadge = p.isAI ? `<span class="badge ai">AI</span>` : '';
        const hasJoker = this.playerDecks[p.id]?.includes('🃏');
        const jokerBadge = hasJoker && !p.jokerUsed ? `<span class="badge charged">조커 준비</span>` : (!hasJoker && p.jokerUsed ? `<span class="badge used">조커 사용됨</span>` : '');
        div.innerHTML = `
          <div class="pname">
            ${this.coloredName(p)}
            ${aiBadge}${jokerBadge}
          </div>
          <div>${hearts}</div>`;
        box.appendChild(div);
      });
    }
    updatePieceSelection(){
      const grid = document.getElementById('piecesGrid');
      grid.innerHTML='';
      const me = this.players[this.currentPlayer];
      if(me.isAI || !me.alive){ grid.innerHTML='<div style="font-size:12px;color:#666">AI 차례입니다...</div>'; return; }
      const deck = this.playerDecks[me.id]||[];
      const count={}; deck.forEach(c=>count[c]=(count[c]||0)+1);
      Object.entries(count).forEach(([sym, n])=>{
        const div=document.createElement('div');
        let cls='pcard';
        if(sym==='🃏') cls += me.jokerUsed ? ' joker-used dis' : ' joker-ready';
        if(this.gamePhase!=='selection') cls += ' dis';
        div.className = cls;
        div.dataset.piece=sym;
        const name = sym==='🃏' ? (me.jokerUsed?'조커(사용됨)':'조커(제자리 공격)') : this.pieces[sym].name;
        div.innerHTML = `<div style="font-size:22px">${sym}</div><div style="font-size:11px;color:#555;margin-top:4px">${name} (${n})</div>`;
        if(this.gamePhase==='selection' && !(sym==='🃏' && me.jokerUsed)){
          div.addEventListener('click',()=>this.selectPiece(sym));
        }
        grid.appendChild(div);
      });
    }
    selectPiece(piece){
      if(this.players[this.currentPlayer].isAI || this.gamePhase!=='selection') return;
      if(piece==='🃏' && this.players[this.currentPlayer].jokerUsed) return;
      this.selectedPiece = piece;
      this.selectedMove = null;
      document.querySelectorAll('.pcard').forEach(e=>e.classList.remove('sel'));
      const card = document.querySelector(`.pcard[data-piece="${piece}"]`);
      if(card) card.classList.add('sel');
      this.showPossibleMoves();
      this.updateTurnInfo();
    }
    showPossibleMoves(){
      document.querySelectorAll('.square').forEach(s=>s.classList.remove('possible','selected'));
      const cur = this.players[this.currentPlayer];
      const curSq = document.querySelector(`.square[data-row="${cur.position.y}"][data-col="${cur.position.x}"]`);
      if(curSq) curSq.classList.add('selected');
      if(!this.selectedPiece) return;
      if(this.selectedPiece==='🃏'){ return; } // 제자리 발동
      const moves = this.getPossibleMoves(this.selectedPiece, cur.position);
      moves.forEach(m=>{
        const sq = document.querySelector(`.square[data-row="${m.y}"][data-col="${m.x}"]`);
        if(sq) sq.classList.add('possible');
      });
    }
    handleSquareClick(row,col){
      if(this.gamePhase!=='selection') return;
      const me = this.players[this.currentPlayer];
      if(me.isAI) return;
      if(!this.selectedPiece) return;
      if(this.selectedPiece==='🃏'){
        this.selectedMove = {x:me.position.x, y:me.position.y};
        document.getElementById('confirmMove').disabled = false;
        return;
      }
      const moves = this.getPossibleMoves(this.selectedPiece, me.position);
      if(moves.some(m=>m.x===col && m.y===row)){
        this.selectedMove = {x:col, y:row};
        document.getElementById('confirmMove').disabled = false;
        document.querySelectorAll('.square').forEach(s=>s.classList.remove('selected'));
        const sq=document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
        if(sq) sq.classList.add('selected');
      }
    }

    initializeDecks(){
      const full = ['♟','♟','♟','♟','♟','♟','♟','♟','♜','♜','♞','♞','♝','♝','♛','♚','🃏'];
      this.players.forEach(p=>{
        this.playerDecks[p.id] = [...full];
        this.shuffleDeck(p.id);
      });
    }
    shuffleDeck(playerId){
      const d=this.playerDecks[playerId];
      for(let i=d.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [d[i],d[j]]=[d[j],d[i]]; }
    }

    confirmMove(){
      if(!this.selectedPiece) return;
      const cur = this.players[this.currentPlayer];
      if(!cur.alive) return;

      this.saveGameState();

      const deck=this.playerDecks[cur.id]; const idx=deck.indexOf(this.selectedPiece);
      if(idx>-1) deck.splice(idx,1);
      if(this.selectedPiece==='🃏') cur.jokerUsed=true;

      this.pendingMoves.push({
        playerId: cur.id,
        piece: this.selectedPiece,
        from: { ...cur.position },
        to: this.selectedPiece==='🃏' ? { ...cur.position } : { ...this.selectedMove },
        isJokerAttack: this.selectedPiece==='🃏',
        staysInPlace: this.selectedPiece==='🃏'
      });

      this.addLog(`${cur.name}이 ${this.selectedPiece==='🃏'?'조커 제자리 공격을':'이동을'} 계획했습니다.`);
      this.selectedPiece=null; this.selectedMove=null;
      document.getElementById('confirmMove').disabled=true;

      this.nextPlayer();
      if(this.pendingMoves.length===this.getAlivePlayers().length){
        setTimeout(()=>this.executeMoves(), 400);
      }
    }

    nextPlayer(){
      let idx = (this.turnOrder.indexOf(this.currentPlayer)+1) % this.turnOrder.length;
      let attempts=0;
      while(!this.players[this.turnOrder[idx]].alive && attempts<5){
        idx = (idx+1) % this.turnOrder.length; attempts++;
      }
      this.currentPlayer = this.turnOrder[idx];
      this.updateDisplay();

      const p = this.players[this.currentPlayer];
      if(p.isAI && p.alive && this.gamePhase==='selection'){
        setTimeout(()=>this.handleAITurn(), 600);
      }
    }

    handleAITurn(){
      const ai = this.players[this.currentPlayer];
      if(!ai.isAI || !ai.alive) return;
      if(this.gamePhase==='ended') return;

      const move = this.calculateAIMove(ai);
      if(!move){
        this.addLog(`🤖 ${ai.name}이 행동을 건너뜁니다.`);
        this.nextPlayer();
        return;
      }

      const deck=this.playerDecks[ai.id]; const idx=deck.indexOf(move.piece);
      if(idx>-1) deck.splice(idx,1);
      if(move.piece==='🃏') ai.jokerUsed=true;

      this.pendingMoves.push({
        playerId: ai.id,
        piece: move.piece,
        from: { ...ai.position },
        to: { ...move.to },
        isJokerAttack: move.piece==='🃏',
        staysInPlace: move.piece==='🃏'
      });

      this.addLog(`🤖 ${ai.name}이 ${move.piece==='🃏'?'조커 제자리 공격':'이동'}을 계획했습니다.`);
      this.nextPlayer();

      if(this.pendingMoves.length===this.getAlivePlayers().length){
        setTimeout(()=>this.executeMoves(), 400);
      }
    }

    calculateAIMove(aiPlayer){
      const deck = this.playerDecks[aiPlayer.id] || [];
      if(deck.length===0) return null;

      const others = this.getAlivePlayers().filter(p=>p.id!==aiPlayer.id);

      if(deck.includes('🃏') && !aiPlayer.jokerUsed){
        const same = others.filter(p=>p.position.x===aiPlayer.position.x && p.position.y===aiPlayer.position.y);
        if(same.length>0){
          return { piece:'🃏', to:{...aiPlayer.position} };
        }
      }

      let bestMove=null, bestScore=-1e9;
      deck.forEach(piece=>{
        if(piece==='🃏') return;
        const moves = this.getPossibleMoves(piece, aiPlayer.position);
        moves.forEach(to=>{
          let score = 0;
          others.forEach(enemy=>{
            const pred = this.predictEnemyNextPos(enemy);
            if(pred.x===to.x && pred.y===to.y){ score += 160; if(enemy.health===1) score += 120; }
            if(enemy.position.x===to.x && enemy.position.y===to.y) score += 90;
          });
          const centerDist = Math.abs(to.x-3.5)+Math.abs(to.y-3.5);
          score += (7-centerDist) * 2;
          if(this.difficulty==='easy'){ score *= 0.85; score += (Math.random()*50-25); }
          else if(this.difficulty==='hard'){ score *= 1.15; score += (7-centerDist)*1.2; }
          else{ score += Math.random()*8; }
          if(aiPlayer.health===1) score -= 12;
          if(aiPlayer.health===3) score += 10;
          if(score>bestScore){ bestScore=score; bestMove={piece,to}; }
        });
      });
      return bestMove;
    }

    predictEnemyNextPos(enemy){
      const candidates = [{...enemy.position}, ...this.getKingMoves(enemy.position)];
      const uniq=[]; candidates.forEach(p=>{ if(this.isValid(p.x,p.y) && !uniq.some(u=>u.x===p.x && u.y===p.y)) uniq.push(p); });
      let best=enemy.position, bestScore=-1e9;
      uniq.forEach(pos=>{
        let s = 0;
        const centerDist = Math.abs(pos.x-3.5)+Math.abs(pos.y-3.5);
        s += (7-centerDist)*2;
        if(enemy.health===1){ s -= (7-centerDist)*3; s += Math.random()*30; }
        else if(enemy.health===3){ s += (7-centerDist)*4; }
        const hasReadyJoker = (this.playerDecks[enemy.id]||[]).includes('🃏') && !enemy.jokerUsed;
        if(hasReadyJoker){ s += 18; }
        if(this.difficulty==='easy') s += (Math.random()*20-10);
        if(this.difficulty==='hard') s += 4;
        if(s>bestScore){ bestScore=s; best=pos; }
      });
      return best;
    }

    executeMoves(){
      this.addLog('=== 이동/공격 실행 ===');
      this.gamePhase='executing';

      const queue = [];
      this.turnOrder.forEach(idx=>{
        const p=this.players[idx];
        if(!p.alive) return;
        const m=this.pendingMoves.find(x=>x.playerId===p.id);
        if(m) queue.push(m);
      });

      let i=0;
      const step = () => {
        if(this.gamePhase==='ended') return;
        if(i>=queue.length){
          this.checkDeckRefresh();
          if(this.checkGameEnd()) return;
          this.pendingMoves=[];
          this.currentTurn++;
          this.rotateTurnOrder();
          this.gamePhase='selection';
          this.updateDisplay();
          const cur=this.players[this.currentPlayer];
          if(cur.isAI && cur.alive){ setTimeout(()=>this.handleAITurn(), 700); }
          return;
        }

        const mv=queue[i];
        const actor=this.players.find(p=>p.id===mv.playerId);
        if(!actor || !actor.alive){ i++; return step(); }

        if(mv.isJokerAttack){
          this.executeJokerAttack(actor, mv, ()=>{
            if(this.gamePhase==='ended') return;
            i++; setTimeout(step, 300);
          });
        }else{
          this.animatePlayerMove(actor, mv, ()=>{
            const ended = this.handleCollisionForPlayer(actor);
            this.renderPieces();
            if(this.gamePhase==='ended' || ended) return;
            i++; setTimeout(step, 180);
          });
        }
      };
      step();
    }

    executeJokerAttack(attacker, mv, done){
      this.addJokerLog(`💀 ${attacker.name}이 조커 제자리 공격 발동!`);
      const kingEl = document.querySelector(`.square[data-row="${attacker.position.y}"][data-col="${attacker.position.x}"] .king.${attacker.color}`);
      if(kingEl) kingEl.classList.add('joker');

      const targets = this.getAlivePlayers().filter(p=>p.id!==attacker.id &&
        p.position.x===attacker.position.x && p.position.y===attacker.position.y);

      if(targets.length===0){
        this.addLog('조커 실패: 같은 칸에 적이 없음.');
        if(kingEl) setTimeout(()=>kingEl.classList.remove('joker'), 550);
        return done && done();
      }

      let killed=false;
      targets.forEach(t=>{
        const before=t.health;
        t.health = Math.max(0, t.health-3);
        this.addJokerLog(`⚡ ${t.name} -3 (${before}→${t.health})`);
        if(t.health<=0){ t.alive=false; killed=true; this.addJokerLog(`💀 ${t.name} 탈락!`); }
      });

      if(killed){
        attacker.jokerUsed=false;
        (this.playerDecks[attacker.id]||[]).push('🃏');
        this.addJokerLog(`🔄 ${attacker.name}의 조커가 재충전되었습니다!`);
      }

      this.renderPieces();
      if(this.checkImmediateDefeat()) return;

      setTimeout(()=>{
        if(kingEl) kingEl.classList.remove('joker');
        if(this.gamePhase==='ended') return;
        this.renderPieces();
        done && done();
      }, 650);
    }

    buildPath(piece, from, to){
      const path=[];
      const isValid = (x,y)=> this.isValid(x,y);

      if(piece==='♞'){
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const sx = Math.sign(dx), sy = Math.sign(dy);
        const ax = Math.abs(dx), ay = Math.abs(dy);
        let cx = from.x, cy = from.y;

        if(ax===2 && ay===1){
          cx += sx; if(isValid(cx,cy)) path.push({x:cx,y:cy});
          cx += sx; if(isValid(cx,cy)) path.push({x:cx,y:cy});
          cy += sy; if(isValid(cx,cy)) path.push({x:cx,y:cy});
        }else if(ax===1 && ay===2){
          cy += sy; if(isValid(cx,cy)) path.push({x:cx,y:cy});
          cy += sy; if(isValid(cx,cy)) path.push({x:cx,y:cy});
          cx += sx; if(isValid(cx,cy)) path.push({x:cx,y:cy});
        }else{
          path.push({x:to.x,y:to.y});
        }
        return path;
      }

      let cx=from.x, cy=from.y;
      const sx = Math.sign(to.x-from.x), sy = Math.sign(to.y-from.y);
      let guard=0;
      while((cx!==to.x || cy!==to.y) && guard++<16){
        if(cx!==to.x) cx += sx;
        if(cy!==to.y) cy += sy;
        if(isValid(cx,cy)) path.push({x:cx,y:cy});
        else break;
      }
      if(path.length===0 || path[path.length-1].x!==to.x || path[path.length-1].y!==to.y){
        if(isValid(to.x,to.y)) path.push({x:to.x,y:to.y});
      }
      return path;
    }

    animatePlayerMove(player, mv, done){
      const from={...mv.from}, to={...mv.to};
      const path = this.buildPath(mv.piece, from, to);
      if(path.length===0){ player.position={...to}; this.renderPieces(); return done && done(); }

      let idx=0;
      const step=()=>{
        if(this.gamePhase==='ended') return;
        const p = path[idx];
        player.position={x:p.x, y:p.y};
        this.renderPieces();
        const k = document.querySelector(`.square[data-row="${p.y}"][data-col="${p.x}"] .king.${player.color}`);
        if(k) k.classList.add('moving');
        setTimeout(()=>{
          if(k) k.classList.remove('moving');
          idx++;
          if(idx>=path.length) return done && done();
          step();
        }, 110);
      };
      step();
    }

    handleCollisionForPlayer(moving){
      const foes = this.getAlivePlayers().filter(p=>p.id!==moving.id &&
        p.position.x===moving.position.x && p.position.y===moving.position.y);
      foes.forEach(d=>{
        d.health = Math.max(0, d.health-1);
        this.addLog(`${moving.name}이 ${d.name}과 충돌! ${d.name} 체력: ${d.health}`);
        if(d.health<=0){ d.alive=false; this.addLog(`💀 ${d.name} 탈락!`); }
      });
      return this.checkImmediateDefeat();
    }

    rotateTurnOrder(){
      const first=this.turnOrder.shift(); this.turnOrder.push(first);
      const names = this.turnOrder.map(i=>this.coloredName(this.players[i])).join(' → ');
      this.addLog('💫 턴 순서 변경: ' + this.turnOrder.map(i=>this.players[i].name).join(' → '));
      this.lastTurnOrderText = '턴 순서 변경: ' + names;
      this.updateTurnInfo();
    }

    checkDeckRefresh(){
      this.players.forEach(p=>{
        if(!p.alive) return;
        const d=this.playerDecks[p.id]||[];
        if(d.length===0){
          this.initializePlayerDeck(p.id);
          this.addLog(`${p.name}의 덱이 초기화되었습니다.`);
        }
      });
    }
    initializePlayerDeck(playerId){
      const p = this.players.find(x=>x.id===playerId);
      const full=['♟','♟','♟','♟','♟','♟','♟','♟','♜','♜','♞','♞','♝','♝','♛','♚'];
      if(!p.jokerUsed) full.push('🃏');
      this.playerDecks[playerId] = [...full];
      this.shuffleDeck(playerId);
    }

    checkImmediateDefeat(){
      const me = this.players.find(p=>!p.isAI);
      if(me && !me.alive && this.gamePhase!=='ended'){
        const msg = '😞 패배... 당신의 왕이 쓰러졌습니다.';
        this.addLog(msg);
        showResultOverlay(msg);
        this.gamePhase='ended';
        return true;
      }
      return false;
    }

    checkGameEnd(){
      if(this.checkImmediateDefeat()) return true;
      const alive = this.getAlivePlayers();
      if(alive.length<=1){
        const winner = alive[0] || null;
        let msg='';
        if(winner && !winner.isAI) msg='🎉 당신의 승리입니다!';
        else msg = `😞 패배... ${(winner?winner.name:'AI')} 승리!`;
        this.addLog(msg);
        showResultOverlay(msg);
        this.gamePhase='ended';
        return true;
      }
      return false;
    }

    getAlivePlayers(){ return this.players.filter(p=>p.alive); }

    resetMove(){
      if(this.players[this.currentPlayer].isAI) return;
      this.selectedPiece=null; this.selectedMove=null;
      document.getElementById('confirmMove').disabled=true;
      this.updateDisplay();
    }
    newGame(){
      this.players.forEach((p,i)=>{
        p.health=3; p.alive=true; p.jokerUsed=false;
        p.position = [ {x:0,y:0},{x:7,y:0},{x:0,y:7},{x:7,y:7} ][i];
      });
      this.currentPlayer=0; this.currentTurn=1; this.turnOrder=[0,1,2,3];
      this.selectedPiece=null; this.selectedMove=null; this.pendingMoves=[];
      this.gamePhase='selection'; this.gameHistory=[];
      document.getElementById('gameLogs').innerHTML='';
      this.initializeDecks();
      this.createBoard();
      this.renderPieces();
      this.lastTurnOrderText = '턴 순서 변경: ' + this.turnOrder.map(i=>this.coloredName(this.players[i])).join(' → ');
      const ov = document.getElementById('resultOverlay'); if(ov) ov.remove();
      this.updateDisplay();
      this.addLog('새 게임 시작!');
      this.addJokerLog('💀 조커 제자리 광역 3데미지 (킬 시 재충전)');
    }
    saveGameState(){
      const state = {
        players: JSON.parse(JSON.stringify(this.players)),
        decks: JSON.parse(JSON.stringify(this.playerDecks)),
        cur: this.currentPlayer, turn:this.currentTurn,
        order:[...this.turnOrder],
        pending: JSON.parse(JSON.stringify(this.pendingMoves)),
        lastTurnOrderText: this.lastTurnOrderText
      };
      this.gameHistory.push(state);
      if(this.gameHistory.length>this.maxHistoryLength) this.gameHistory.shift();
    }
    undoMove(){
      if(this.gamePhase==='executing'){ this.addLog('실행 중에는 무르기 불가.'); return; }
      const prev = this.gameHistory.pop();
      if(!prev){ this.addLog('무를 수 있는 이전 상태가 없습니다.'); return; }
      this.players=prev.players; this.playerDecks=prev.decks;
      this.currentPlayer=prev.cur; this.currentTurn=prev.turn; this.turnOrder=prev.order;
      this.pendingMoves=prev.pending; this.lastTurnOrderText = prev.lastTurnOrderText || this.lastTurnOrderText;
      this.selectedPiece=null; this.selectedMove=null;
      this.gamePhase='selection'; this.updateDisplay();
      this.addLog('🔄 한 턴 전으로 되돌렸습니다.');
      const cur=this.players[this.currentPlayer];
      if(cur.isAI && cur.alive){ setTimeout(()=>this.handleAITurn(),700); }
    }
    updateUndoButton(){
      const b=document.getElementById('undoMove');
      if(b) b.disabled = this.gameHistory.length===0 || this.gamePhase==='ended';
    }

    bindEvents(){
      document.getElementById('confirmMove').onclick=()=>this.confirmMove();
      document.getElementById('resetMove').onclick = ()=>this.resetMove();
      document.getElementById('undoMove').onclick  = ()=>this.undoMove();
      document.getElementById('newGame').onclick   = ()=>this.newGame();
      document.getElementById('toMenu').onclick    = ()=>{ showScreen('startScreen'); };
    }

    addLog(msg){
      const logs=document.getElementById('gameLogs');
      const d=document.createElement('div'); d.className='log'; d.textContent=msg; logs.appendChild(d);
      logs.scrollTop=logs.scrollHeight;
    }
    addJokerLog(msg){
      const logs=document.getElementById('gameLogs');
      const d=document.createElement('div'); d.className='log joker'; d.textContent=msg; logs.appendChild(d);
      logs.scrollTop=logs.scrollHeight;
    }

    isValid(x,y){ return x>=0 && x<8 && y>=0 && y<8; }

    getPossibleMoves(piece, from){
      if(piece==='🃏') return [{...from}];
      return this.pieces[piece].moves.call(this, from);
    }
    getPawnMoves(from){
      const mv=[];
      for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){
        if(dx===0&&dy===0) continue;
        const nx=from.x+dx, ny=from.y+dy;
        if(this.isValid(nx,ny)) mv.push({x:nx,y:ny});
      }
      return mv;
    }
    getRookMoves(from){
      const mv=[], dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      dirs.forEach(([dx,dy])=>{
        for(let i=1;i<8;i++){
          const nx=from.x+dx*i, ny=from.y+dy*i; if(!this.isValid(nx,ny)) break;
          mv.push({x:nx,y:ny});
        }
      });
      return mv;
    }
    getBishopMoves(from){
      const mv=[], dirs=[[1,1],[1,-1],[-1,1],[-1,-1]];
      dirs.forEach(([dx,dy])=>{
        for(let i=1;i<8;i++){
          const nx=from.x+dx*i, ny=from.y+dy*i; if(!this.isValid(nx,ny)) break;
          mv.push({x:nx,y:ny});
        }
      });
      return mv;
    }
    getQueenMoves(from){ return [...this.getRookMoves(from), ...this.getBishopMoves(from)]; }
    getKnightMoves(from){
      const steps=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
      return steps.map(([dx,dy])=>({x:from.x+dx, y:from.y+dy})).filter(p=>this.isValid(p.x,p.y));
    }
    getKingMoves(from){
      const mv=[];
      for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){
        if(dx===0&&dy===0) continue;
        const nx=from.x+dx, ny=from.y+dy;
        if(this.isValid(nx,ny)) mv.push({x:nx,y:ny});
      }
      return mv;
    }
    getJokerMoves(from){ return [{...from}]; }
  }

  /* --- PWA: 서비스워커 등록 & 설치 버튼 --- */
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js').catch(console.error);
    });
  }
  let deferredPrompt;
  const installBtn = document.getElementById('installBtn');
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    if(installBtn) installBtn.style.display = 'inline-flex';
  });
  if(installBtn){
    installBtn.addEventListener('click', async () => {
      if(!deferredPrompt) return;
      deferredPrompt.prompt();
      await deferredPrompt.userChoice;
      deferredPrompt = null;
      installBtn.style.display = 'none';
    });
  }
  window.addEventListener('appinstalled', () => {
    console.log('PWA installed');
  });
</script>
</body>
</html>
